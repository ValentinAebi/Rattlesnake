interface Super {
    x: Int
}

struct Sub : Super {
    var x: Int,
    y: String
}

struct Indep {
    i: Int
}

interface I {}

package Test {

    fn create() -> Super {
        return new Sub(10, "Hello");
    }

    fn testFunc() -> String {
        val a = create() as Sub;
        val b: Super = a;
        var s = readY(a) + " ";     // s: "Hello "
        val e = a as String;  // ERROR: unrelated types
        print(e);
        val f = a as Super;   // WARNING: useless cast
        setX(f);
        val aPrime: Sub = a;
        val bPrime: Super = b;
        val g = aPrime as Indep;   // ERROR: unrelated types
        val h = bPrime as Indep;   // ERROR: unrelated types
        print(boolToString(g == h));
        val i = aPrime as I;    // ERROR: unrelated types
        val j = bPrime as I;    // ERROR: unrelated types
        print(boolToString(i == j));
        setX(b);
        s += readY(b as Sub);       // s: "Hello Hello"
        s += " ";                   // s: "Hello Hello "
        s += intToString(a.x);      // s: "Hello Hello 42"
        return s;
    }

    fn setX(s: Super){
        (s as Sub).x = 42;
    }

    fn setXSub(s: Sub){
        s.x = 50;
    }

    fn readY(s: Sub) -> String {
        return s.y;
    }

}
