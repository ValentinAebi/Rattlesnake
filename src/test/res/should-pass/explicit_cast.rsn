
interface Super {
    x: Int
}

struct Sub : Super {
    var x: Int,
    y: String
}

package Test {

    fn create() -> Super {
        return new Sub(10, "Hello");
    }

    fn testFunc() -> String {
        val a = me.create() as Sub;
        var s = me.readY(a) + " ";  // s: "Hello "
        val b: Super = a;
        me.setX(b);
        s += me.readY(b as Sub);    // s: "Hello Hello"
        s += " ";                   // s: "Hello Hello "
        s += intToString(a.x);   // s: "Hello Hello 42"
        return s;
    }

    fn setX(s: Super){
        (s as Sub).x = 42;
    }

    fn readY(s: Sub) -> String {
        return s.y;
    }

}
