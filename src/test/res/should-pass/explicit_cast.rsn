
interface Super {
    var x: Int
}

struct Sub : Super {
    var x: Int,
    y: String
}

package Test {

    fn create(reg: Region^) -> Super^{reg} {
        return new@reg Sub(10, "Hello");
    }

    fn testFunc() -> String {
        val r = newregion;
        val a = me.create(r) as Sub;
        var s = me.readY(a) + " ";  // s: "Hello "
        val b: Super^{r} = a;
        me.setX(r, b);
        s += me.readY(b as Sub);    // s: "Hello Hello"
        s += " ";                   // s: "Hello Hello "
        s += intToString(a.x);   // s: "Hello Hello 42"
        return s;
    }

    fn setX(r: Region^, s: Super^{r}){
        (s as Sub).x = 42;
    }

    fn readY(s: Sub^) -> String {
        return s.y;
    }

}
